##软件设计原则
- 开闭原则: 对扩展开放，对修改关闭。强调的是用抽象构建框架，用实现扩展细节。

- 依赖倒置原则: 设计代码结构时，高层模块不应该依赖底层模块，二者应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。
    
- 单一职责原则: 一个类，一个方法，只做一件事情，保证单一性。

- 接口隔离原则: 尽量保证接口功能的纯洁性。比如动物接口，细分为吃，飞，游泳3个接口。  

- 迪米特法则: 最少知道原则

- 里是替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能。

- 合成复用原则: 尽量使用对用组合/聚合，而不是继承关系达到软件复用的目的。


## Spring中用到的设计模式

- 工厂模式 BeanFactory
- 装饰器模式 BeanWrapper
- 代理模式 AopProxy
- 单例模式 ApplicationContext
- 委派模式 DispatcherServlet
- 适配器模式 HandlerMapping
- 模板方法模式 JDBCTemplate
- 观察者模式 ContextLoaderListener


 ## 设计模式
 what when why
 
 ### 工厂模式
 
 - 简单工厂模式
    - 指由一个工厂对象决定创建出哪一种产品类的实例
 
 - 工厂方法模式
    - 定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行
 
 - 抽象工厂模式
    - 指提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。
 
 
 ### 单例模式
 - 饿汉式单例
    - 类加载就完成初始化。
 - 懒汉式单例
 
    - 使用 Synchronized
    - double check
        ```java
        
        if (lazy == null) {
            Synchronized(this.class){
                if (lazy == null) {
                    lazy = new lazy();
                }
            }
        }
        
        ```
     - 静态内部类的方式
     
            ```java
             public class A{
                private A(){
                    if (B.A != null) {
                      // 抛异常，防止反射攻击
                    }
                }
                public static final A instance(){
                    return B.A;
                }
                
                private static class B {
                     private static final A = new A();
                }
             }
            
            ```
      - 通过序列化的方式也能破坏单例。重写`readResolve()` 方法，返回单例对象，即可。

 
 - 注册式单例
    - 枚举式：序列化反序列化，枚举是通过类名和Value来判断的。JDK 层面，就保证了枚举单例不能被序列化和反射破坏。
    - 注册式：使用 `static map`,通过 get 方法去取，去的时候使用 `Synchronized`，因为，即使是 `ConcurrentHashMap` 也只能保证自己内部操作原子性。
        
 
 - ThreadLocal单例
    - 伪线程安全，只能保证线程内的安全。
 
 
 #### 破坏单例模式的方式
 
 1. 通过反射来获取。 
    - 避免方法，通过在私有构造函数中增加判断并抛异常。
 2. 通过序列化来获取。
    - 重写 readResolve 方法。
 
 ### 原型模式
 原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
 
 #### 使用场景
 
 1. 类初始化消耗资源较多
 2. new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
 3. 构造函数比较复杂
 4. 循环体中生产大量对象时
 
 #### 浅克隆 和 深克隆
 
 
 ### 代理模式
 为其他对象提供一种代理，以控制对这个对象的访问。
 
 代理对象在客户端和目标对象之间起到中介作用。
 
 #### 应用场景
 
 #### 静态代理和动态代理的区别
 
 - 静态代理
    - 持有代理对象的引用，通过构造函数注入
    - 显示声明代理对象
    
 - 动态代理（CGLib 和 JDK Proxy）
    - 通过字节码重组，编变成一个新的类，然后来代理。
 
 
 #### CGLib 和 JDK Proxy 的区别
 JDK Proxy 实现接口。
 CGLib 继承。
 
 - JDK Proxy
    1. 拿到被代理类的引用，并且获取它的所有的接口（反射获取）
    2. JDK Proxy类重新生成一个新的类，实现了被代理类所有接口的方法。
    3. 动态生成Java代码，把增强逻辑加入到新生成代码中。
    4. 编译生成新的Java代码的class文件
    5. 加载并重新运行新的class，得到类就是全新类。
 
 - CGLib
 
 CGLib 生成代理逻辑更复杂，效率，调用效率更高，生成一个包含了所有逻辑的Fastclass，不再需要反射调用。
 
 CGLib 不能代理final的方法。 
 
 JDK Proxy 生成代理的逻辑加单，执行效率相对较低，每次都反射动态调用。
 
 
 ### 委派模式
 负责任务的调度和分配任务。跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。
 
 代理模式会增加前后逻辑，委派一般直接调用。 
 

 ### 策略模式
 定义了算法家族、分别封装起来，让他们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户。
 
 可以避免多重分支模式。
 
 #### 适用场景
 1. 加入系统中有很多类，而他们的区别仅仅在于他们的行为不同。
 2. 一个系统需要动态地在几种算法中选择一种。
 
 
 
 ### 模板模式
 
 
 #### 适用场景
  1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
  2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。
 
 
 
 
 ### 适配器模式
 
 将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作。
 
 一般解决兼容问题。
 
 
 ### 装饰者模式
 
  
             装饰器模式                          |   适配器模式
             -----------------------------------+---------------------------------
             是一种非常特别的适配器模式            |  可以不保留层级关系
             -----------------------------------+---------------------------------
             装饰者和被装饰者都要实现同一个接口     |  适配者和被适配者没有必然的层级联系
             主要目的是为了扩展，依旧保留OOP关系    |  通常采用代理或者继承形式进行包装
             -----------------------------------+----------------------------------
             满足is-a的关系                      |   满足has-a
             -----------------------------------+----------------------------------
             注重的是覆盖、扩展                   |   注重兼容、转换
             
 
 
 
 
 
 ### 观察者模式
 
 定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主体对象发生变化，它的所有依赖者（观察者）都会受到通知并更新，
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 